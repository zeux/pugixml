[article pugixml
    [quickbook 1.5]

	[version 0.9]
	[id manual]
	[copyright 2010 Arseny Kapoulkine]
	[license Distributed under the MIT License]
]

[template file[name] '''<filename>'''[name]'''</filename>''']
[template sbr[] '''<sbr/>''']
[template lbr[] '''<sbr/><sbr/>'''] [/ for empty lines in lists]
[template sref[name] '''<xref linkend="'''[name]'''" xrefstyle="select:title" />''']
[template anchor[name] '''<anchor id="'''[name]'''" />'''[^[name]]]

PugiXML User Manual

$$$ documentation suggestions, errors, etc. are welcome
$$$ proofreading

$$$ ideally code samples should reference manual parts - i.e. xml_parse_result and doc.child() should be clickable
$$$ do something with main TOC

[section:overview Overview]

[section:introduction Introduction]

$$$ minimalistic/lightweight; why should the user choose pugixml?
$$$ pugixml can write xml data too!
$$$ unicode support
$$$ low memory consumption and fragmentation
$$$ this is the ref manual; here is the quick-start guide, here are the code samples

pugixml is a C++ XML $$processing library$$. It consists of a DOM-like interface with rich traversal/modification capabilities, an extremely fast XML parser which constructs the DOM tree from an XML file/buffer, and a XPath 1.0 implementation for complex data-driven tree queries. The library is [link manual.install.portability extremely portable] and easy to integrate and use. pugixml is developed and maintained since 2006 and has ^many users^. All code is distributed under the MIT license, making it completely free to use even in commercial applications.

Please note that pugixml's parser is a non-validating one; if you either need to process XML documents that do not fit in memory or need DTD/Schema validation, the library is not for you.

[endsect] [/introduction]

[section:feedback Feedback]

If you believe you've found a bug in pugixml (bugs include compilation problems (errors/warnings), crashes, performance degradation and incorrect behavior), please file an issue via [@http://code.google.com/p/pugixml/issues/entry issue submission form]. Be sure to include the relevant information so that the bug can be reproduced: the version of pugixml, compiler version and target architecture, the code that uses pugixml and exhibits the bug, etc.

Feature requests can be reported the same way as bugs, so if you're missing some functionality in pugixml or if the API is rough in some places and you can suggest an improvement, file an issue. However please note that there are many factors when considering API changes (compatibility with previous versions, API redundancy, etc.), so generally features that can be implemented via a small function without pugixml modification are not accepted. However, all rules have exceptions.

If you have a contribution to pugixml, such as build script for some build system/IDE, or a well-designed set of helper functions, or a binding to some language other than C++, please file an issue. You can include the relevant patches as issue attachments. Your contribution has to be distributed under the terms of a license that's compatible with pugixml license; i.e. GPL/LGPL licensed code is not accepted.

[#email]
If filing an issue is not possible due to privacy or other concerns, you can contact pugixml author by e-mail directly: [@mailto:arseny.kapoulkine@gmail.com arseny.kapoulkine@gmail.com].

[endsect] [/feedback]

[section:thanks Acknowledgments]

pugixml could not be developed without the help from many people; some of them are listed in this section. If you've played a part in pugixml development and you can not find yourself on this list, I'm truly sorry; please [link email send me an e-mail] so I can fix this.

Thanks to *Kristen Wegner* for pugxml parser, which was used as a basis for pugixml.

Thanks to *Neville Franks* for contributions to pugxml parser.

Thanks to *Artyom Palvelev* for suggesting a lazy gap contraction approach.

Thanks to *Vyacheslav Egorov* for documentation proofreading.

[endsect] [/thanks]

[section:license License]

The pugixml library is distributed under the MIT license:

[:
Copyright (c) 2006-2010 Arseny Kapoulkine

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
]

[endsect] [/license]

[endsect] [/overview]
 
[section:install Installation]

[section:getting Getting pugixml]

pugixml is distributed in source form. You can either download a source distribution or checkout the Subversion repository.

[section:source Source distributions]

You can download the latest source distribution via one of the following links:

[pre
[@http://pugixml.googlecode.com/files/pugixml-0.9.zip]
[@http://pugixml.googlecode.com/files/pugixml-0.9.tar.gz]
]

The distribution contains library source, documentation (the user manual you're reading now and the quick start guide) and some code examples. After downloading the distribution, install pugixml by extracting all files from the compressed archive.

If you need an older version, you can download it from the [@http://code.google.com/p/pugixml/downloads/list version archive].

[endsect] [/source]

[section:subversion Subversion repository]

The Subversion repository is located at [@http://pugixml.googlecode.com/svn/]. There is a Subversion tag "release-{version}" for each version; also there is the "latest" tag, which always points to the latest stable release.

For example, to checkout the current version, you can use this command:

[pre svn checkout http://pugixml.googlecode.com/svn/tags/release-0.9 pugixml]

To checkout the latest version, you can use this command:

[pre svn checkout http://pugixml.googlecode.com/svn/tags/latest pugixml]

The repository contains library source, documentation, code examples and full unit test suite.

Use latest version tag if you want to automatically get new versions via =svn update=. Use other tags if you want to switch to new versions only explicitly (for example, using =svn switch= command). Also please note that Subversion trunk contains the work-in-progress version of the code; while this means that you can get new features and bug fixes from trunk without waiting for a new release, this also means that occasionally the code can be broken in some configurations.

[endsect] [/subversion]

[endsect] [/getting]

[section:building Building pugixml]

pugixml is distributed in source form without any pre-built binaries; you have to build them yourself.
 
The complete pugixml source consists of four files - two source files, [file pugixml.cpp] and [file pugixpath.cpp], and two header files, [file pugixml.hpp] and [file pugiconfig.hpp]. [file pugixml.hpp] is the primary header which you need to include in order to use pugixml classes/functions; [file pugiconfig.hpp] is a supplementary configuration file (see [sref manual.install.building.config]). The rest of this guide assumes that [file pugixml.hpp] is either in the current directory or in one of include directories of your projects, so that `#include "pugixml.hpp"` can find the header; however you can also use relative path (i.e. `#include "../libs/pugixml/src/pugixml.hpp"`) or include directory-relative path (i.e. `#include <xml/thirdparty/pugixml/src/pugixml.hpp>`).
 
[note You don't need to compile [file pugixpath.cpp] unless you use XPath.]

[section:embed Building pugixml as a part of another static library/executable]
 
The easiest way to build pugixml is to compile two source files, [file pugixml.cpp] and [file pugixpath.cpp], along with the existing library/executable. This process depends on the method of building your application; for example, if you're using Microsoft Visual Studio[footnote All trademarks used are properties of their respective owners.], Apple Xcode, Code::Blocks or any other IDE, just add [file pugixml.cpp] and [file pugixpath.cpp] to one of your projects.

If you're using Microsoft Visual Studio and the project has precompiled headers turned on, you'll see the following error messages:

[pre pugixpath.cpp(3477) : fatal error C1010: unexpected end of file while looking for precompiled header. Did you forget to add '#include "stdafx.h"' to your source?]

The correct way to resolve this is to disable precompiled headers for [file pugixml.cpp] and [file pugixpath.cpp]; you have to set "Create/Use Precompiled Header" option (Properties dialog -> C/C++ -> Precompiled Headers -> Create/Use Precompiled Header) to "Not Using Precompiled Headers". You'll have to do it for both [file pugixml.cpp] and [file pugixpath.cpp], for all project configurations/platforms (you can select Configuration "All Configurations" and Platform "All Platforms" before editing the option):

[table
[[
[@images/vs2005_pch1.png [$images/vs2005_pch1_thumb.png]]
[$images/next.png]
[@images/vs2005_pch2.png [$images/vs2005_pch2_thumb.png]]
[$images/next.png]
[@images/vs2005_pch3.png [$images/vs2005_pch3_thumb.png]]
[$images/next.png]
[@images/vs2005_pch4.png [$images/vs2005_pch4_thumb.png]]
]] ]
 
[endsect] [/embed]

[section:static Building pugixml as a standalone static library]
 
It's possible to compile pugixml as a standalone static library. This process depends on the method of building your application; pugixml distribution comes with project files for several popular IDEs/build systems. There are project files for Apple XCode3, Code::Blocks, Codelite, Microsoft Visual Studio 2002, 2003 (.NET), 2005, 2008, 2010, and configuration scripts for CMake and premake4. You're welcome to submit project files/build scripts for other software; see [sref manual.overview.feedback]. 

$$ debug/release static

In addition to adding pugixml project to your workspace, you'll have to make sure that your application links with pugixml library. If you're using Microsoft Visual Studio 2002-2008, you can add a dependency from your application project to pugixml one. If you're using Microsoft Visual Studio 2010, you'll have to add a reference to your application project instead. For other IDEs/systems, consult the relevant documentation.

[table
[[Microsoft Visual Studio 2002-2008][Microsoft Visual Studio 2010]]
[[
[@images/vs2005_link1.png [$images/vs2005_link1_thumb.png]]
[$images/next.png]
[@images/vs2005_link2.png [$images/vs2005_link2_thumb.png]]
][
[@images/vs2010_link1.png [$images/vs2010_link1_thumb.png]]
[$images/next.png]
[@images/vs2010_link2.png [$images/vs2010_link2_thumb.png]]
]] ]

[endsect] [/static]

[section:shared Building pugixml as a standalone shared library]
 
It's possible to compile pugixml as a standalone shared library. The process is usually similar to the static library approach; however, no preconfigured projects/scripts are included into pugixml distribution, so you'll have to do it yourself. Generally, if you're using GCC-based toolchain, the process does not differ from building any other library as DLL (adding -shared to compilation flags should suffice); if you're using MSVC-based toolchain, you'll have to explicitly mark exported symbols with a declspec attribute. You can do it by defining `PUGIXML_API` macro, i.e. via [file pugiconfig.hpp]:

	#ifdef _DLL
	#define PUGIXML_API __declspec(dllexport)
	#else
	#define PUGIXML_API __declspec(dllimport)
	#endif

[endsect] [/shared]
 
[section:config Additional configuration options]

pugixml uses several defines to control the compilation process. There are two ways to define them: either put the needed definitions to [file pugiconfig.hpp] (it has some examples that are commented out) or provide them via compiler command-line. Define consistency is important, i.e. the definitions should match in all source files that include [file pugixml.hpp] (including pugixml sources) throughout the application. Adding defines to [file pugiconfig.hpp] lets you guarantee this, unless your macro definition is wrapped in preprocessor `#if`/`#ifdef` directive and this directive is not consistent. [file pugiconfig.hpp] will never contain anything but comments, which means that when upgrading to new version, you can safely leave your modified version intact.

[anchor PUGIXML_WCHAR_MODE] define toggles between UTF-8 style interface (the in-memory text encoding is assumed to be UTF-8, most functions use `char` as character type) and UTF-16/32 style interface (the in-memory text encoding is assumed to be UTF-16/32, depending on `wchar_t` size, most functions use `wchar_t` as character type). See [sref manual.dom.unicode] for more details.

[anchor PUGIXML_NO_XPATH] define disables XPath. Both XPath interfaces and XPath implementation are excluded from compilation; you can still compile the file [file pugixpath.cpp] (it will result in an empty translation unit). This option is provided in case you do not need XPath functionality and need to save code space.

[anchor PUGIXML_NO_STL] define disables use of STL in pugixml. The functions that operate on STL types are no longer present (i.e. load/save via iostream) if this macro is defined. This option is provided in case your target platform does not have a standard-compliant STL implementation.

[note As of version 0.9, STL is used in XPath implementation; therefore, XPath is also disabled if this macro is defined. This will change in version 1.0.]

[anchor PUGIXML_NO_EXCEPTIONS] define disables use of exceptions in pugixml. This option is provided in case your target platform does not have exception handling capabilities

[note As of version 0.9, exceptions are *only* used in XPath implementation; therefore, XPath is also disabled if this macro is defined. This will change in version 1.0.]

[anchor PUGIXML_API], [anchor PUGIXML_CLASS] and [anchor PUGIXML_FUNCTION] defines let you specify custom attributes (i.e. declspec or calling conventions) for pugixml classes and non-member functions. In absence of `PUGIXML_CLASS` or `PUGIXML_FUNCTION` definitions, `PUGIXML_API` definition is used instead. For example, to specify fixed calling convention, you can define `PUGIXML_FUNCTION` to i.e. `__fastcall`. Another example is DLL import/export attributes in MSVC (see [sref manual.install.building.shared]).

[note In that example `PUGIXML_API` is inconsistent between several source files; this is an exception to the consistency rule.]
 
[endsect] [/config]

[endsect] [/building]

[section:portability Portability]

pugixml is written in standard-compliant C++ with some compiler-specific workarounds where appropriate. pugixml is compatible with the upcoming C++0x standard (verified using GCC 4.5). Each version is tested with a unit test suite (with code coverage about 99%) on the following platforms:

* Microsoft Windows:
    * Borland C++ Compiler 5.82
    * Digital Mars C++ Compiler 8.51
    * Intel C++ Compiler 8.0, 9.0 x86/x64, 10.0 x86/x64, 11.0 x86/x64
    * Metrowerks CodeWarrior 8.0
    * Microsoft Visual C++ 6.0, 7.0 (2002), 7.1 (2003), 8.0 (2005) x86/x64, 9.0 (2008) x86/x64, 10.0 (2010) x86/x64
    * MinGW (GCC) 3.4, 4.4, 4.5, 4.6 x64

* Linux (GCC 4.4.3 x86/x64)
* FreeBSD (GCC 4.2.1 x86/x64)
* Apple MacOSX (GCC 4.0.1 x86/x64/PowerPC)
* Microsoft Xbox 360
* Nintendo Wii (Metrowerks CodeWarrior 4.1)
* Sony Playstation Portable (GCC 3.4.2)
* Sony Playstation 3 (GCC 4.1.1, SNC 310.1)

[endsect] [/portability]

[endsect] [/install]

[section:dom Document object model]

pugixml stores XML data in DOM-like way: the entire XML document (both document structure and element data) is stored in memory as a tree. The tree can be loaded from character stream (file, string, C++ I/O stream), then traversed via special API or XPath expressions. The whole tree is mutable: both node structure and node/attribute data can be changed at any time. Finally, the result of document transformations can be saved to a character stream (file, C++ I/O stream or custom transport).

[section:tree Tree structure]

The XML document is represented with a tree data structure. The root of the tree is the document itself, which corresponds to C++ type `xml_document`. Document has one or more child nodes, which correspond to C++ type `xml_node`. Nodes have different types; depending on a type, a node can have a collection of child nodes, a collection of attributes, which correspond to C++ type `xml_attribute`, and some additional data (i.e. name).

[#xml_node_type]
The tree nodes can be of one of the following types (which together form the enumeration `xml_node_type`):

* Document node ([anchor node_document]) - this is the root of the tree, which consists of several child nodes. This node corresponds to `xml_document` class; note that `xml_document` is a sub-class of `xml_node`, so the entire node interface is also available. However, document node is special in several ways, which will be covered below. There can be only one document node in the tree; document node does not have any XML representation.
[lbr]

* Element/tag node ([anchor node_element]) - this is the most common type of node, which represents XML elements. Element nodes have a name, a collection of attributes and a collection of child nodes (both of which may be empty). The attribute is a simple name/value pair. The example XML representation of element node is as follows:

	<node attr="value"><child/></node>

[:There are two element nodes here; one has name `"node"`, single attribute `"attr"` and single child `"child"`, another has name `"child"` and does not have any attributes or child nodes.]

* Plain character data nodes ([anchor node_pcdata]) represent plain text in XML. PCDATA nodes have a value, but do not have name or children/attributes. Note that plain character data is not a part of the element node but instead has its own node; for example, and element node can have several child PCDATA nodes. The example XML representation of text node is as follows:

	<node> text1 <child/> text2 </node>

[:Here `"node"` element has three children, two of which are PCDATA nodes with values `"text1"` and `"text2"`.]

* Character data nodes ([anchor node_cdata]) represent text in XML that is quoted in a special way. CDATA nodes do not differ from PCDATA nodes except in XML representation - the above text example looks like this with CDATA:

	<node> <![CDATA[[text1]]> <child/> <![CDATA[[text2]]> </node>

[:CDATA nodes make it easy to include non-escaped <, & and > characters in plain text. CDATA value can not contain the character sequence \]\]>, since it is used to determine the end of node contents.]

* Comment nodes ([anchor node_comment]) represent comments in XML. Comment nodes have a value, but do not have name or children/attributes. The example XML representation of comment node is as follows:

	<!-- comment text -->

[:Here the comment node has value `"comment text"`. By default comment nodes are treated as non-essential part of XML markup and are not loaded during XML parsing. You can override this behavior by adding `parse_comments` flag.]

* Processing instruction node ([anchor node_pi]) represent processing instructions (PI) in XML. PI nodes have a name and an optional value, but do not have children/attributes. The example XML representation of PI node is as follows:

	<?name value?>

[:Here the name (also called PI target) is `"name"`, and the value is `"value"`. By default PI nodes are treated as non-essential part of XML markup and are not loaded during XML parsing. You can override this behavior by adding `parse_pi` flag.]

* Declaration node ([anchor node_declaration]) represents document declarations in XML. Declaration nodes have a name (`"xml"`) and an optional collection of attributes, but does not have value or children. There can be only one declaration node in a document; moreover, it should be the topmost node (it's parent should be the document). The example XML representation of declaration node is as follows:

	<?xml version="1.0"?>

[:Here the node has name `"xml"` and a single attribute with name `"version"` and value `"1.0"`. By default declaration nodes are treated as non-essential part of XML markup and are not loaded during XML parsing. You can override this behavior by adding `parse_declaration` flag. Also, by default a dummy declaration is output when XML document is saved unless there is already a declaration in the document; you can disable this by adding `format_no_declaration` flag.]

Finally, here is a complete example of XML document and the corresponding tree representation ([@samples/tree.xml]):

[table

[[
``
	<?xml version="1.0"?>
	<mesh name="mesh_root">
		<!-- here is a mesh node -->
		some text
		<![CDATA[[someothertext]]>
		some more text
		<node attr1="value1" attr2="value2" />
		<node attr1="value2">
			<innernode/>
		</node>
	</mesh>
	<?include somedata?>
``
][
[@images/dom_tree.png [$images/dom_tree_thumb.png]]
]]]


[endsect] [/tree]

[section:cpp C++ interface]

[note All pugixml classes and functions are located in `pugi` namespace; you have to either use explicit name qualification (i.e. `pugi::xml_node`), or to gain access to relevant symbols via `using` directive (i.e. `using pugi::xml_node;` or `using namespace pugi;`). The namespace will be omitted from declarations in this documentation hereafter; all code examples will use fully-qualified names.]

Despite the fact that there are several node types, there are only three C++ types representing the tree (`xml_document`, `xml_node`, `xml_attribute`); some operations on `xml_node` are only valid for certain node types. They are described below.

[#xml_document]
`xml_document` is the owner of the entire document structure; it is a non-copyable class. The interface of `xml_document` consists of loading functions (see [sref manual.loading]), saving functions (see [sref manual.saving]) and the interface of `xml_node`, which allows for document inspection and/or modification. Note that while `xml_document` is a sub-class of `xml_node`, `xml_node` is not a polymorphic type; the inheritance is only used to simplify usage.

[#xml_document::ctor]
[#xml_document::dtor]
Default constructor of `xml_document` initializes the document to the tree with only a root node (document node). You can then populate it with data using either tree modification functions or loading functions; all loading functions destroy the previous tree with all occupied memory, which puts existing nodes/attributes from this document to invalid state. Destructor of `xml_document` also destroys the tree, thus the lifetime of the document object should exceed the lifetimes of any node/attribute handles that point to the tree.

[caution While technically node/attribute handles can be alive when the tree they're referring to is destroyed, calling any member function of these handles results in undefined behavior. Thus it is recommended to make sure that the document is destroyed only after all references to its nodes/attributes are destroyed.]

[#xml_node]
[#xml_node::type]
`xml_node` is the handle to document node; it can point to any node in the document, including document itself. There is a common interface for nodes of all types; the actual node type can be queried via `xml_node::type()` method. Note that `xml_node` is only a handle to the actual node, not the node itself - you can have several `xml_node` handles pointing to the same underlying object. Destroying `xml_node` handle does not destroy the node and does not remove it from the tree. The size of `xml_node` is equal to that of a pointer, so it is nothing more than a lightweight wrapper around pointer; you can safely pass or return `xml_node` objects by value without additional overhead.

[#node_null]
There is a special value of `xml_node` type, known as null node or empty node (such nodes have type `node_null`). It does not correspond to any node in any document, and thus resembles null pointer. However, all operations are defined on empty nodes; generally the operations don't do anything and return empty nodes/attributes or empty strings as their result (see documentation for specific functions for more detailed information). This is useful for chaining calls; i.e. you can get the grandparent of a node like so: `node.parent().parent()`; if a node is a null node or it does not have a parent, the first `parent()` call returns null node; the second `parent()` call then also returns null node, so you don't have to check for errors twice.

[#xml_attribute]
`xml_attribute` is the handle to a XML attribute; it has the same semantics as `xml_node`, i.e. there can be several `xml_attribute` handles pointing to the same underlying object, there is a special null attribute value, which propagates to function results.

[#xml_attribute::ctor]
[#xml_node::ctor]
Both `xml_node` and `xml_attribute` have the default constructor which initializes them to null objects.

[#xml_attribute::comparison]
[#xml_node::comparison]
`xml_node` and `xml_attribute` try to behave like pointers, that is, they can be compared with other objects of the same type, making it possible to use them as keys of associative containers. All handles to the same underlying object are equal, and any two handles to different underlying objects are not equal. Null handles only compare as equal to themselves. The result of relational comparison can not be reliably determined from the order of nodes in file or other ways. Do not use relational comparison operators except for search optimization (i.e. associative container keys).

[#xml_attribute::unspecified_bool_type]
[#xml_node::unspecified_bool_type]
[#xml_attribute::empty]
[#xml_node::empty]
Additionally handles they can be implicitly cast to boolean-like objects, so that you can test if the node\/attribute is empty by just doing `if (node) { ... }` or `if (!node) { ... } else { ... }`. Alternatively you can check if a given `xml_node`/`xml_attribute` handle is null by calling the following methods:

	bool xml_attribute::empty() const;
	bool xml_node::empty() const;

Nodes and attributes do not exist outside of document tree, so you can't create them without adding them to some document. Once underlying node/attribute objects are destroyed, the handles to those objects become invalid. While this means that destruction of the entire tree invalidates all node/attribute handles, it also means that destroying a subtree (by calling `remove_child`) or removing an attribute invalidates the corresponding handles. There is no way to check handle validity; you have to ensure correctness through external mechanisms.

[endsect] [/cpp]

[section:unicode Unicode interface]

There are two choices of interface and internal representation when configuring pugixml: you can either choose the UTF-8 (also called char) interface or UTF-16/32 (also called wchar_t) one. The choice is controlled via `PUGIXML_WCHAR_MODE` define; you can set it via [file pugiconfig.hpp] or via preprocessor options, as discussed in [sref manual.install.building.config]. If this define is set, the wchar_t interface is used; otherwise (by default) the char interface is used. The exact wide character encoding is assumed to be either UTF-16 or UTF-32 and is determined based on size of `wchar_t` type.

[note If size of `wchar_t` is 2, pugixml assumes UTF-16 encoding instead of UCS-2, which means that some characters are represented as two code points.]

All tree functions that work with strings work with either C-style null terminated strings or STL strings of the selected character type. For example, node name accessors look like this in char mode:

	const char* xml_node::name() const;
	bool xml_node::set_name(const char* value);

and like this in wchar_t mode:

	const wchar_t* xml_node::name() const;
	bool xml_node::set_name(const wchar_t* value);

[#char_t]
[#string_t]
There is a special type, `pugi::char_t`, that is defined as the character type and depends on the library configuration; it will be also used in the documentation hereafter. There is also a type `pugi::string_t`, which is defined as the STL string of the character type; it corresponds to `std::string` in char mode and to `std::wstring` in wchar_t mode.

In addition to the interface, the internal implementation changes to store XML data as `pugi::char_t`; this means that these two modes have different memory usage characteristics. The conversion to `pugi::char_t` upon document loading and from `pugi::char_t` upon document saving happen automatically, which also carries minor performance penalty. The general advice however is to select the character mode based on usage scenario, i.e. if UTF-8 is inconvenient to process and most of your XML data is localized, wchar_t mode is probably a better choice.

[#as_utf8]
[#as_wide]
There are cases when you'll have to convert string data between UTF-8 and wchar_t encodings; the following helper functions are provided for such purposes:

	std::string as_utf8(const wchar_t* str);
	std::wstring as_wide(const char* str);

Both functions accept null-terminated string as an argument `str`, and return the converted string. `as_utf8` performs conversion from UTF-16/32 to UTF-8; `as_wide` performs conversion from UTF-8 to UTF-16/32. Invalid UTF sequences are silently discarded upon conversion. `str` has to be a valid string; passing null pointer results in undefined behavior.

[note Most examples in this documentation assume char interface and therefore will not compile with `PUGIXML_WCHAR_MODE`. This is to simplify the documentation; usually the only changes you'll have to make is to pass `wchar_t` string literals, i.e. instead of

`pugi::xml_node node = doc.child("bookstore").find_child_by_attribute("book", "id", "12345");`

you'll have to do

`pugi::xml_node node = doc.child(L"bookstore").find_child_by_attribute(L"book", L"id", L"12345");`]
 
[endsect] [/unicode]

[section:thread Thread-safety guarantees]

Almost all functions in pugixml have the following thread-safety guarantees:

* it is safe to call free functions from multiple threads
* it is safe to perform concurrent read-only accesses to the same tree (all constant member functions do not modify the tree)
* it is safe to perform concurrent read/write accesses, if there is only one read or write access to the single tree at a time

Concurrent modification and traversing of a single tree requires synchronization, for example via reader-writer lock. Modification includes altering document structure and altering individual node/attribute data, i.e. changing names/values.

The only exception is `set_memory_management_functions`; it modifies global variables and as such is not thread-safe. Its usage policy has more restrictions, see [sref manual.dom.memory.custom].

[endsect] [/thread]

[section:exception Exception guarantees]

With the exception of XPath, pugixml itself does not throw any exceptions. Additionally, most pugixml functions have a no-throw exception guarantee.

This is not applicable to functions that operate on STL strings or IOstreams; such functions have either strong guarantee (functions that operate on strings) or basic guarantee (functions that operate on streams). Also functions that call user-defined callbacks (i.e. `xml_node::traverse` or `xml_node::all_elements_by_name`) do not provide any exception guarantees beyond the ones provided by callback.

XPath functions may throw `xpath_exception` on parsing error; also, XPath implementation uses STL, and thus may throw i.e. `std::bad_alloc` in low memory conditions. Still, XPath functions provide strong exception guarantee.

[endsect] [/exception]

[section:memory Memory management]

pugixml requests the memory needed for document storage in big chunks, and allocates document data inside those chunks. This section discusses replacing functions used for chunk allocation and internal memory management implementation.

[section:custom Custom memory allocation/deallocation functions]

[#allocation_function]
[#deallocation_function]
All memory for tree structure/data is allocated via globally specified functions, which default to malloc/free. You can set your own allocation functions with set_memory_management functions. The function interfaces are the same as that of malloc/free:

	typedef void* (*allocation_function)(size_t size);
	typedef void (*deallocation_function)(void* ptr);

[#set_memory_management_functions]
[#get_memory_allocation_function]
[#get_memory_deallocation_function]
You can use the following accessor functions to change or get current memory management functions:

	void set_memory_management_functions(allocation_function allocate, deallocation_function deallocate);
	allocation_function get_memory_allocation_function();
	deallocation_function get_memory_deallocation_function();

Allocation function is called with the size (in bytes) as an argument and should return a pointer to memory block with alignment that is suitable for pointer storage and size that is greater or equal to the requested one. If the allocation fails, the function has to return null pointer (throwing an exception from allocation function results in undefined behavior). Deallocation function is called with the pointer that was returned by the previous call or with a null pointer; null pointer deallocation should be handled as a no-op. If memory management functions are not thread-safe, library thread safety is not guaranteed.

This is a simple example of custom memory management ([@samples/custom_memory_management.cpp]):

[import samples/custom_memory_management.cpp]
[code_custom_memory_management_decl]
[code_custom_memory_management_call]

When setting new memory management functions, care must be taken to make sure that there are no live pugixml objects. Otherwise when the objects are destroyed, the new deallocation function will be called with the memory obtained by the old allocation function, resulting in undefined behavior.

[note Currently memory for XPath objects is allocated using default operators new/delete; this will change in the next version.]

[endsect] [/custom]

[section:internals Document memory management internals]

Constructing a document object using the default constructor does not result in any allocations; document node is stored inside the `xml_document` object.

When the document is loaded from file/buffer, unless an inplace loading function is used (see [sref manual.loading.memory]), a complete copy of character stream is made; all names/values of nodes and attributes are allocated in this buffer. This buffer is allocated via a single large allocation and is only freed when document memory is reclaimed (i.e. if the `xml_document` object is destroyed or if another document is loaded in the same object). Also when loading from file or stream, an additional large allocation may be performed if encoding conversion is required; a temporary buffer is allocated, and it is freed before load function returns.

All additional memory, such as memory for document structure (node/attribute objects) and memory for node/attribute names/values is allocated in pages on the order of 32 kilobytes; actual objects are allocated inside the pages using a memory management scheme optimized for fast allocation/deallocation of many small objects. Because of the scheme specifics, the pages are only destroyed if all objects inside them are destroyed; also, generally destroying an object does not mean that subsequent object creation will reuse the same memory. This means that it is possible to devise a usage scheme which will lead to higher memory usage than expected; one example is adding a lot of nodes, and them removing all even numbered ones; not a single page is reclaimed in the process. However this is an example specifically crafted to produce unsatisfying behavior; in all practical usage scenarios the memory consumption is less than that of a general-purpose allocator because allocation meta-data is very small in size.

[endsect] [/internals]

[endsect] [/memory]

[endsect] [/dom]

[section:loading Loading document]

pugixml provides several functions for loading XML data from various places - files, C++ iostreams, memory buffers. All functions use an extremely fast non-validating parser. This parser is not fully W3C conformant - it can load any valid XML document, but does not perform some well-formedness checks. While considerable effort is made to reject invalid XML documents, some validation is not performed because of performance reasons. Also some XML transformations (i.e. EOL handling or attribute value normalization) can impact parsing speed and thus can be disabled. However for vast majority of XML documents there is no performance difference between different parsing options. Parsing options also control whether certain XML nodes are parsed; see [sref manual.loading.options] for more information.

XML data is always converted to internal character format (see [sref manual.dom.unicode]) before parsing. pugixml supports all popular Unicode encodings (UTF-8, UTF-16 (big and little endian), UTF-32 (big and little endian); UCS-2 is naturally supported since it's a strict subset of UTF-16) and handles all encoding conversions automatically. Unless explicit encoding is specified, loading functions perform automatic encoding detection based on first few characters of XML data, so in almost all cases you do not have to specify document encoding. Encoding conversion is described in more detail in [sref manual.loading.encoding].

[section:file Loading document from file]

[#xml_document::load_file]
The most common source of XML data is files; pugixml provides a separate function for loading XML document from file:

	xml_parse_result xml_document::load_file(const char* path, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);
	
This function accepts file path as its first argument, and also two optional arguments, which specify parsing options (see [sref manual.loading.options]) and input data encoding (see [sref manual.loading.encoding]). The path has the target operating system format, so it can be a relative or absolute one, it should have the delimiters of target system, it should have the exact case if target file system is case-sensitive, etc. File path is passed to system file opening function as is.

`load_file` destroys the existing document tree and then tries to load the new tree from the specified file. The result of the operation is returned in a `xml_parse_result` object; this object contains the operation status, and the related information (i.e. last successfully parsed position in the input file, if parsing fails). See [sref manual.loading.errors] for error handling details.

[note As of version 0.9, there is no function for loading XML document from wide character path. Unfortunately, there is no portable way to do this; the version 1.0 will provide such function only for platforms with the corresponding functionality. You can use stream-loading functions as a workaround if your STL implementation can open file streams via `wchar_t` paths.]

This is a simple example of loading XML document from file ([@samples/load_file.cpp]):

[import samples/load_file.cpp]
[code_load_file]

[endsect] [/file]

[section:memory Loading document from memory]

[#xml_document::load_buffer]
[#xml_document::load_buffer_inplace]
[#xml_document::load_buffer_inplace_own]
Sometimes XML data should be loaded from some other source than file, i.e. HTTP URL; also you may want to load XML data from file using non-standard functions, i.e. to use your virtual file system facilities or to load XML from gzip-compressed files. All these scenarios require loading document from memory. First you should prepare a contiguous memory block with all XML data; then you have to invoke one of buffer loading functions. These functions will handle the necessary encoding conversions, if any, and then will parse the data into the corresponding XML tree. There are several buffer loading functions, which differ in the behavior and thus in performance/memory usage:

	xml_parse_result xml_document::load_buffer(const void* contents, size_t size, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);
	xml_parse_result xml_document::load_buffer_inplace(void* contents, size_t size, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);
	xml_parse_result xml_document::load_buffer_inplace_own(void* contents, size_t size, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);

All functions accept the buffer which is represented by a pointer to XML data, `contents`, and data size in bytes. Also there are two optional arguments, which specify parsing options (see [sref manual.loading.options]) and input data encoding (see [sref manual.loading.encoding]). The buffer does not have to be zero-terminated.

`load_buffer` function works with immutable buffer - it does not ever modify the buffer. Because of this restriction it has to create a private buffer and copy XML data to it before parsing (applying encoding conversions if necessary). This copy operation carries a performance penalty, so inplace functions are provided - `load_buffer_inplace` and `load_buffer_inplace_own` store the document data in the buffer, modifying it in the process. In order for the document to stay valid, you have to make sure that the buffer's lifetime exceeds that of the tree if you're using inplace functions. In addition to that, `load_buffer_inplace` does not assume ownership of the buffer, so you'll have to destroy it yourself; `load_buffer_inplace_own` assumes ownership of the buffer and destroys it once it is not needed. This means that if you're using `load_buffer_inplace_own`, you have to allocate memory with pugixml allocation function (you can get it via [link get_memory_allocation_function]).

The best way from the performance/memory point of view is to load document using `load_buffer_inplace_own`; this function has maximum control of the buffer with XML data so it is able to avoid redundant copies and reduce peak memory usage while parsing. This is the recommended function if you have to load the document from memory and performance is critical.

[#xml_document::load_string]
There is also a simple helper function for cases when you want to load the XML document from null-terminated character string:

	xml_parse_result xml_document::load(const char_t* contents, unsigned int options = parse_default);

It is equivalent to calling `load_buffer` with `size = strlen(contents)`. This function assumes native encoding for input data, so it does not do any encoding conversion. In general, this function is fine for loading small documents from string literals, but has more overhead and less functionality than buffer loading functions.

This is an example of loading XML document from memory using different functions ([@samples/load_memory.cpp]):

[import samples/load_memory.cpp]
[code_load_memory_decl]
[code_load_memory_buffer]
[code_load_memory_buffer_inplace]
[code_load_memory_buffer_inplace_own]
[code_load_memory_string]

[endsect] [/memory]

[section:stream Loading document from C++ IOstreams]

[#xml_document::load_stream]
For additional interoperability pugixml provides functions for loading document from any object which implements C++ `std::istream` interface. This allows you to load documents from any standard C++ stream (i.e. file stream) or any third-party compliant implementation (i.e. Boost Iostreams). There are two functions, one works with narrow character streams, another handles wide character ones:

	xml_parse_result xml_document::load(std::istream& stream, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);
	xml_parse_result xml_document::load(std::wistream& stream, unsigned int options = parse_default);

`load` with `std::istream` argument loads the document from stream from the current read position to the end, treating the stream contents as a byte stream of the specified encoding (with encoding autodetection as necessary). Thus calling `xml_document::load` on an opened `std::ifstream` object is equivalent to calling `xml_document::load_file`.

`load` with `std::wstream` argument treats the stream contents as a wide character stream (encoding is always `encoding_wchar`). Because of this, using `load` with wide character streams requires careful (usually platform-specific) stream setup (i.e using the `imbue` function). Generally use of wide streams is discouraged, however it provides you the ability to load documents from non-Unicode encodings, i.e. you can load Shift-JIS encoded data if you set the correct locale.

This is a simple example of loading XML document from file using streams ([@samples/load_stream.cpp]); read the sample code for more complex examples involving wide streams and locales:

[import samples/load_stream.cpp]
[code_load_stream]

Stream loading requires working seek/tell functions and therefore may fail when used with some stream implementations like gzstream.

[endsect] [/stream]

[section:errors Handling parsing errors]

[#xml_parse_result]
All document loading functions return the parsing result via `xml_parse_result` object. It contains parsing status, the offset of last successfully parsed character from the beginning of the source stream, and the encoding of the source stream:

	struct xml_parse_result
	{
		xml_parse_status status;
		ptrdiff_t offset;
		xml_encoding encoding;

		operator bool() const;
		const char* description() const;
	};

[#xml_parse_status]
[#xml_parse_result::status]
Parsing status is represented as the `xml_parse_status` enumeration and can be one of the following:

* [anchor status_ok] means that no error was encountered during parsing; the source stream represents the valid XML document which was fully parsed and converted to a tree.
[lbr]

* [anchor status_file_not_found] is only returned by `load_file` function and means that file could not be opened.
* [anchor status_io_error] is returned by `load_file` function and by `load` functions with `std::istream`/`std::wstream` arguments; it means that some I/O error has occured during reading the file/stream.
* [anchor status_out_of_memory] means that there was not enough memory during some allocation; any allocation failure during parsing results in this error.
* [anchor status_internal_error] means that something went horribly wrong; currently this error does not occur
[lbr]

* [anchor status_unrecognized_tag] means that parsing stopped due to a tag with either an empty name or a name which starts with incorrect character, such as [^#].
* [anchor status_bad_pi] means that parsing stopped due to incorrect document declaration/processing instruction
* [anchor status_bad_comment], [anchor status_bad_cdata], [anchor status_bad_doctype] and [anchor status_bad_pcdata] mean that parsing stopped due to the invalid construct of the respective type
* [anchor status_bad_start_element] means that parsing stopped because starting tag either had no closing `>` symbol or contained some incorrect symbol
* [anchor status_bad_attribute] means that parsing stopped because there was an incorrect attribute, such as an attribute without value or with value that is not quoted (note that `<node attr=1>` is incorrect in XML)
* [anchor status_bad_end_element] means that parsing stopped because ending tag had incorrect syntax (i.e. extra non-whitespace symbols between tag name and `>`)
* [anchor status_end_element_mismatch] means that parsing stopped because the closing tag did not match the opening one (i.e. `<node></nedo>`) or because some tag was not closed at all

[#xml_parse_result::description]
`description()` member function can be used to convert parsing status to a string; the returned message is always in English, so you'll have to write your own function if you need a localized string. However please note that the exact messages returned by `description()` function may change from version to version, so any complex status handling should be based on `status` value.

If parsing failed because the source data was not a valid XML, the resulting tree is not destroyed - despite the fact that load function returns error, you can use the part of the tree that was successfully parsed. Obviously, the last element may have an unexpected name/value; for example, if the attribute value does not end with the necessary quotation mark, like in [^<node attr="value>some data</node>] example, the value of attribute `attr` will contain the string `value>some data</node>`.

[#xml_parse_result::offset]
In addition to the status code, parsing result has an `offset` member, which contains the offset of last successfully parsed character if parsing failed because of an error in source data; otherwise `offset` is 0. For parsing efficiency reasons, pugixml does not track the current line during parsing; this offset is in units of `pugi::char_t` (bytes for character mode, wide characters for wide character mode). Many text editors support 'Go To Position' feature - you can use it to locate the exact error position. Alternatively, if you're loading the document from memory, you can display the error chunk along with the error description (see the example code below).

[caution Offset is calculated in the XML buffer in native encoding; if encoding conversion is performed during parsing, offset can not be used to reliably track the error position.]

[#xml_parse_result::encoding]
Parsing result also has an `encoding` member, which can be used to check that the source data encoding was correctly guessed. It is equal to the exact encoding used during parsing (i.e. with the exact endianness); see [sref manual.loading.encoding] for more information.

[#xml_parse_result::bool]
Parsing result object can be implicitly converted to `bool`; if you do not want to handle parsing errors thoroughly, you can just check the return value of load functions as if it was a `bool`: `if (doc.load_file("file.xml")) { ... } else { ... }`.

This is a simple example of handling loading errors ([@samples/load_error_handling.cpp]):

[import samples/load_error_handling.cpp]
[code_load_error_handling]

[endsect] [/errors]

[section:options Parsing options]

All document loading functions accept the optional parameter `options`. This is a bitmask that customizes the parsing process: you can select the node types that are parsed and various transformations that are performed with the XML text. Disabling certain transformations can improve parsing performance for some documents; however, the code for all transformations is very well optimized, and thus the majority of documents won't get any performance benefit. As a rule of thumb, only modify parsing flags if you want to get some nodes in the document that are excluded by default (i.e. declaration or comment nodes).

[note You should use the usual bitwise arithmetics to manipulate the bitmask: to enable a flag, use `mask | flag`; to disable a flag, use `mask & ~flag`.]

These flags control the resulting tree contents:

* [anchor parse_declaration] determines if XML document declaration (node with type [link node_declaration]) are to be put in DOM tree. If this flag is off, it is not put in the tree, but is still parsed and checked for correctness. This flag is *off* by default.
[lbr]

* [anchor parse_pi] determines if processing instructions (nodes with type [link node_pi]) are to be put in DOM tree. If this flag is off, they are not put in the tree, but are still parsed and checked for correctness. Note that `<?xml ...?>` (document declaration) is not considered to be a PI. This flag is *off* by default.
[lbr]

* [anchor parse_comments] determines if comments (nodes with type [link node_comment]) are to be put in DOM tree. If this flag is off, they are not put in the tree, but are still parsed and checked for correctness. This flag is *off* by default.
[lbr]

* [anchor parse_cdata] determines if CDATA sections (nodes with type [link node_cdata]) are to be put in DOM tree. If this flag is off, they are not put in the tree, but are still parsed and checked for correctness. This flag is *on* by default.
[lbr]

* [anchor parse_ws_pcdata] determines if PCDATA nodes (nodes with type [link node_pcdata]) that consist only of whitespace characters are to be put in DOM tree. Often whitespace-only data is not significant for the application, and the cost of allocating and storing such nodes (both memory and speed-wise) can be significant. For example, after parsing XML string `<node> <a/> </node>`, `<node>` element will have three children when `parse_ws_pcdata` is set (child with type `node_pcdata` and value `" "`, child with type `node_element` and name `"a"`, and another child with type `node_pcdata` and value `" "`), and only one child when `parse_ws_pcdata` is not set. This flag is *off* by default.

These flags control the transformation of tree element contents:

* [anchor parse_escapes] determines if character and entity references are to be expanded during the parsing process. Character references have the form [^&#...;] or [^&#x...;] ([^...] is Unicode numeric representation of character in either decimal ([^&#...;]) or hexadecimal ([^&#x...;]) form), entity references are [^&lt;], [^&gt;], [^&amp;], [^&apos;] and [^&quot;] (note that as pugixml does not handle DTD, the only allowed entities are predefined ones). If character/entity reference can not be expanded, it is left as is, so you can do additional processing later. Reference expansion is performed in attribute values and PCDATA content. This flag is *on* by default.
[lbr]

* [anchor parse_eol] determines if EOL handling (that is, replacing sequences `0x0d 0x0a` by a single `0x0a` character, and replacing all standalone `0x0d` characters by `0x0a`) is to be performed on input data (that is, comments contents, PCDATA/CDATA contents and attribute values). This flag is *on* by default.
[lbr]

* [anchor parse_wconv_attribute] determines if attribute value normalization should be performed for all attributes. This means, that whitespace characters (new line, tab and space) are replaced with space (`' '`). New line characters are always treated as if `parse_eol` is set, i.e. `\r\n` is converted to single space.  This flag is *on* by default.
[lbr]

* [anchor parse_wnorm_attribute] determines if extended attribute value normalization should be performed for all attributes. This means, that after attribute values are normalized as if `parse_wconv_attribute` was set, leading and trailing space characters are removed, and all sequences of space characters are replaced by a single space character. The value of `parse_wconv_attribute` has no effect if this flag is on. This flag is *off* by default.

[note `parse_wconv_attribute` option performs transformations that are required by W3C specification for attributes that are declared as [^CDATA]; `parse_wnorm_attribute` performs transformations required for [^NMTOKENS] attributes. In the absence of document type declaration all attributes behave as if they are declared as [^CDATA], thus `parse_wconv_attribute` is the default option.]

Additionally there are two predefined option masks:

* [anchor parse_minimal] has all options turned off. This option mask means that pugixml does not add declaration nodes, PI nodes, CDATA sections and comments to the resulting tree and does not perform any conversion for input data, so theoretically it is the fastest mode. However, as discussed above, in practice `parse_default` is usually equally fast.
[lbr]

* [anchor parse_default] is the default set of flags, i.e. it has all options set to their default values. It includes parsing CDATA sections (comments/PIs are not parsed), performing character and entity reference expansion, replacing whitespace characters with spaces in attribute values and performing EOL handling. Note, that PCDATA sections consisting only of whitespace characters are not parsed (by default) for performance reasons.

This is a simple example of using different parsing options ([@samples/load_options.cpp]):

[import samples/load_options.cpp]
[code_load_options]

[endsect] [/options]

[section:encoding Encodings]

[#xml_encoding]
pugixml supports all popular Unicode encodings (UTF-8, UTF-16 (big and little endian), UTF-32 (big and little endian); UCS-2 is naturally supported since it's a strict subset of UTF-16) and handles all encoding conversions. Most loading functions accept the optional parameter `encoding`. This is a value of enumeration type `xml_encoding`, that can have the following values:

* [anchor encoding_auto] means that pugixml will try to guess the encoding based on source XML data. The algorithm is a modified version of the one presented in Appendix F.1 of XML recommendation; it tries to match the first few bytes of input data with the following patterns in strict order:
[lbr]
	* If first four bytes match UTF-32 BOM (Byte Order Mark), encoding is assumed to be UTF-32 with the endianness equal to that of BOM;
	* If first two bytes match UTF-16 BOM, encoding is assumed to be UTF-16 with the endianness equal to that of BOM;
	* If first three bytes match UTF-8 BOM, encoding is assumed to be UTF-8;
	* If first four bytes match UTF-32 representation of [^<], encoding is assumed to be UTF-32 with the corresponding endianness;
	* If first four bytes match UTF-16 representation of [^<?], encoding is assumed to be UTF-16 with the corresponding endianness;
	* If first two bytes match UTF-16 representation of [^<], encoding is assumed to be UTF-16 with the corresponding endianness (this guess may yield incorrect result, but it's better than UTF-8);
	* Otherwise encoding is assumed to be UTF-8.
	[lbr]

* [anchor encoding_utf8] corresponds to UTF-8 encoding as defined in Unicode standard; UTF-8 sequences with length equal to 5 or 6 are not standard and are rejected.
* [anchor encoding_utf16_le] corresponds to little-endian UTF-16 encoding as defined in Unicode standard; surrogate pairs are supported.
* [anchor encoding_utf16_be] corresponds to big-endian UTF-16 encoding as defined in Unicode standard; surrogate pairs are supported.
* [anchor encoding_utf16] corresponds to UTF-16 encoding as defined in Unicode standard; the endianness is assumed to be that of target platform.
* [anchor encoding_utf32_le] corresponds to little-endian UTF-32 encoding as defined in Unicode standard.
* [anchor encoding_utf32_be] corresponds to big-endian UTF-32 encoding as defined in Unicode standard.
* [anchor encoding_utf32] corresponds to UTF-32 encoding as defined in Unicode standard; the endianness is assumed to be that of target platform.
* [anchor encoding_wchar] corresponds to the encoding of `wchar_t` type; it has the same meaning as either `encoding_utf16` or `encoding_utf32`, depending on `wchar_t` size.

The algorithm used for `encoding_auto` correctly detects any supported Unicode encoding for all well-formed XML documents (since they start with document declaration) and for all other XML documents that start with [^<]; if your XML document does not start with [^<] and has encoding that is different from UTF-8, use the specific encoding.

[note The current behavior for Unicode conversion is to skip all invalid UTF sequences during conversion. This behavior should not be relied upon; moreover, in case no encoding conversion is performed, the invalid sequences are not removed, so you'll get them as is in node/attribute contents.]

[endsect] [/encoding]

[section:w3c Conformance to W3C specification]

pugixml is not fully W3C conformant - it can load any valid XML document, but does not perform some well-formedness checks. While considerable effort is made to reject invalid XML documents, some validation is not performed because of performance reasons.

There is only one non-conformant behavior when dealing with valid XML documents: pugixml does not use information supplied in document type declaration for parsing. This means that entities declared in DOCTYPE are not expanded, and all attribute/PCDATA values are always processed in a uniform way that depends only on parsing options.

As for rejecting invalid XML documents, there are a number of incompatibilities with W3C specification, including:

* Multiple attributes of the same node can have equal names.
* All non-ASCII characters are treated in the same way as symbols of English alphabet, so some invalid tag names are not rejected.
* Attribute values which contain [^<] are not rejected.
* Invalid entity/character references are not rejected and are instead left as is.
* Comment values can contain [^--].
* XML data is not required to begin with document declaration; additionally, document declaration can appear after comments and other nodes.
* Invalid document type declarations are silently ignored in some cases.

[endsect] [/w3c]

[endsect] [/loading]

[section:getting Getting data from document $$$]

pugixml features an extensive interface for getting various types of data from the document and for traversing the document. This section provides documentation for all such functions that do not modify the tree except for XPath-related functions; see [sref manual.xpath] for XPath reference. As discussed in [sref manual.dom.cpp], there are two types of handles to tree data - [link xml_node] and [link xml_attribute]. The handles have special null (empty) values which propagate through various functions and thus are useful for writing more concise code; see [link node_null this description] for details. The documentation in this section will explicitly state the results of all function in case of null inputs.

[import samples/traverse_base.cpp]

[section:basic Basic traversal functions]

[#xml_node::parent][#xml_node::first_child][#xml_node::last_child][#xml_node::next_sibling][#xml_node::previous_sibling][#xml_node::first_attribute][#xml_node::last_attribute][#xml_attribute::next_attribute][#xml_attribute::previous_attribute]
The internal representation of the document is a tree, where each node has a list of child nodes (the order of children corresponds to their order in the XML representation), and additionally element nodes have a list of attributes, which is also ordered. Several functions are provided in order to let you get from one node in the tree to the other. These functions roughly correspond to the internal representation, and thus are usually building blocks for other methods of traversing (i.e. XPath traversals are based on these functions).

	xml_node xml_node::parent() const;
	xml_node xml_node::first_child() const;
	xml_node xml_node::last_child() const;
	xml_node xml_node::next_sibling() const;
	xml_node xml_node::previous_sibling() const;

	xml_attribute xml_node::first_attribute() const;
	xml_attribute xml_node::last_attribute() const;
	xml_attribute xml_attribute::next_attribute() const;
	xml_attribute xml_attribute::previous_attribute() const;

`parent` function returns the node's parent; all nodes except the document have non-null parent. `first_child` and `last_child` return the first and last child of the node, respectively; note that only document nodes and element nodes can have non-empty child node list. If node has no children, both functions return null nodes. `next_sibling` and `previous_sibling` return the node that's immediately to the right\/left of this node in the children list, respectively - for example, in `<a/><b/><c/>`, calling `next_sibling` for a handle that points to `<b/>` results in a handle pointing to `<c/>`, and calling `previous_sibling` results in handle pointing to `<a/>`. If node does not have next/previous sibling (this happens if it is the last/first node in the list, respectively), the functions return null nodes. `first_attribute`, `last_attribute`, `next_attribute` and `previous_attribute` functions behave the same way as corresponding child node functions and allow to iterate through attribute list in the same way.

[note Because of memory consumption reasons, attributes do not have a link to their parent nodes. Thus there is no `xml_attribute::parent()` function.]

Calling any of the functions above on the null handle results in a null handle - i.e. `node.first_child().next_sibling()` returns the second child of `node`, and null handle if there is no children at all or if there is only one.

With these functions, you can iterate through all child nodes and display all attributes like this ([@samples/traverse_base.cpp]):

[code_traverse_base_basic]

[endsect] [/basic]

[section:nodedata Getting node data]

[#xml_node::name][#xml_node::value]
Apart from structural information (parent, child nodes, attributes), nodes can have name and value, both of which are strings. Depending on node type, name or value may be absent. `node_document` nodes do not have name or value, `node_element` and `node_declaration` nodes always have a name but never have a value, `node_pcdata`, `node_cdata` and `node_comment` nodes never have a name but always have a value (it may be empty though), `node_pi` nodes always have a name and a value (again, value may be empty). In order to get node's name or value, you can use the following functions:

	const char_t* xml_node::name() const;
	const char_t* xml_node::value() const;

In case node does not have a name or value or if the node handle is null, both functions return empty strings - they never return null pointers.

[#xml_node::child_value]
It is common to store data as a text contents of some node - i.e. `<node><description>This is a node</description></node>`. In this case, `<description>` node does not have a value, but instead has a child of type `node_pcdata` with value `"This is a node"`. pugixml provides two helper functions to parse such data:

	const char_t* xml_node::child_value() const;
	const char_t* xml_node::child_value(const char_t* name) const;

`child_value()` returns the value of the first child with type `node_pcdata` or `node_cdata`; `child_value(name)` is a simple wrapper for `child(name).child_value()`. For the above example, calling `node.child_value("description")` and `description.child_value()` will both produce string `"This is a node"`. If there is no child with relevant type, or if the handle is null, `child_value` functions return empty string.

There is an example of using some of these functions [link code_traverse_base_data at the end of the next section].

[endsect] [/nodedata]

[section:attrdata Getting attribute data]

[#xml_attribute::name][#xml_attribute::value]
All attributes have name and value, both of which are strings (value may be empty). There are two corresponding accessors, like for `xml_node`:

	const char_t* xml_attribute::name() const;
	const char_t* xml_attribute::value() const;

In case attribute handle is null, both functions return empty strings - they never return null pointers.

[#xml_attribute::as_int][#xml_attribute::as_uint][#xml_attribute::as_double][#xml_attribute::as_float][#xml_attribute::as_bool]
In many cases attribute values have types that are not strings - i.e. an attribute may always contain values that should be treated as integers, despite the fact that they are represented as strings in XML. pugixml provides several accessors that convert attribute value to some other type. The accessors are as follows:

	int xml_attribute::as_int() const;
	unsigned int xml_attribute::as_uint() const;
	double xml_attribute::as_double() const;
	float xml_attribute::as_float() const;
	bool xml_attribute::as_bool() const;

`as_int`, `as_uint`, `as_double` and `as_float` convert attribute values to numbers. If attribute handle is null or attribute value is empty, `0` is returned. Otherwise, all leading whitespace characters are truncated, and the remaining string is parsed as a decimal number (`as_int` or `as_uint`) or as a floating point number in either decimal or scientific form (`as_double` or `as_float`). Any extra characters are silently discarded, i.e. `as_int` will return `1` for string `"1abc"`.

In case the input string contains a number that is out of the target numeric range, the result is undefined.

[caution Number conversion functions depend on current C locale as set with `setlocale`, so may return unexpected results if the locale is different from `"C"`.]

`as_bool` converts attribute value to boolean as follows: if attribute handle is null or attribute value is empty, `false` is returned. Otherwise, `true` is returned if first character is one of `'1', 't', 'T', 'y', 'Y'`. This means that strings like `"true"` and `"yes"` are recognized as `true`, while strings like `"false"` and `"no"` are recognized as `false`. For more complex matching you'll have to write your own function.

[note There are no portable 64-bit types in C++, so there is no corresponding conversion function. If your platform has a 64-bit integer, you can easily write a conversion function yourself.]

[#code_traverse_base_data]
Here is a simple example of using these functions, along with node data retrieval ones ([@samples/traverse_base.cpp]):

[code_traverse_base_data]

[endsect] [/attrdata]

[section:contents Contents-based traversal functions]

[#xml_node::child][#xml_node::attribute][#xml_node::next_sibling_name][#xml_node::previous_sibling_name]
Since a lot of document traversal consists of finding the node/attribute with the correct name, there are special functions for that purpose:

	xml_node xml_node::child(const char_t* name) const;
	xml_attribute xml_node::attribute(const char_t* name) const;
	xml_node xml_node::next_sibling(const char_t* name) const;
	xml_node xml_node::previous_sibling(const char_t* name) const;

`child` and `attribute` return the first child/attribute with the specified name; `next_sibling` and `previous_sibling` return the first sibling in the corresponding direction with the specified name. All string comparisons are case-sensitive. In case the node handle is null or there is no node\/attribute with the specified name, null handle is returned.

`child` and `next_sibling` functions can be used together to loop through all child nodes with the desired name like this:

    for (pugi::xml_node tool = tools.child("Tool"); tool; tool = tool.next_sibling("Tool"))

[#xml_node::find_child_by_attribute]
Occasionally the needed node is specified not by the unique name but instead by the value of some attribute; for example, it is common to have node collections with each node having a unique id: `<group><item id="1"/> <item id="2"/></group>`. There are two functions for finding child nodes based on the attribute values:

	xml_node xml_node::find_child_by_attribute(const char_t* name, const char_t* attr_name, const char_t* attr_value) const;
	xml_node xml_node::find_child_by_attribute(const char_t* attr_name, const char_t* attr_value) const;

The three-argument function returns the first child node with the specified name which has an attribute with the specified name/value; the two-argument function skips the name test for the node, which can be useful for searching in heterogeneous collections. If the node handle is null or if no node is found, null handle is returned. All string comparisons are case-sensitive.

In all of the above functions, all arguments have to be valid strings; passing null pointers results in undefined behavior.

Here is a simple example of using these functions ([@samples/traverse_base.cpp]):

[code_traverse_base_contents]

[endsect] [/contents]

[section:iterators Iterators $$$]
[endsect] [/iterators]

[section:walker Walker $$$]
[endsect] [/walker]

[section:predicate Predicate $$$]
[endsect] [/predicate]

[endsect] [/getting]

[section:modify Modifying document $$$]
[endsect] [/modify]

[section:saving Saving document]
[endsect] [/saving]

[section:xpath XPath $$$]

$$$ standard violations
$$$ performance checklist

[endsect] [/xpath]

[section:changes Changelog]

$$$ move somewhere else

[h5 1.07.2010 - version 0.9]

Major release, featuring extended and improved Unicode support, miscellaneous performance improvements, bug fixes and more.

* Major Unicode improvements:
	# Introduced encoding support (automatic/manual encoding detection on load, manual encoding selection on save, conversion from/to UTF8, UTF16 LE/BE, UTF32 LE/BE)
	# Introduced wchar_t mode (you can set PUGIXML_WCHAR_MODE define to switch pugixml internal encoding from UTF8 to wchar_t; all functions are switched to their Unicode variants)
	# Load/save functions now support wide streams

* Bug fixes:
	# Fixed document corruption on failed parsing bug
	# XPath string <-> number conversion improvements (increased precision, fixed crash for huge numbers)
	# Improved DOCTYPE parsing: now parser recognizes all well-formed DOCTYPE declarations
	# Fixed xml_attribute::as_uint() for large numbers (i.e. 2^32-1)

* Specification changes:
	# parse() API changed to load_buffer/load_buffer_inplace/load_buffer_inplace_own; load_buffer APIs do not require zero-terminated strings.
	# Renamed as_utf16 to as_wide
	# Changed xml_node::offset_debug return type and xml_parse_result::offset type to ptrdiff_t
	# Nodes/attributes with empty names are now printed as :anonymous

* Performance improvements:
	# Optimized document parsing and saving
	# Changed internal memory management: internal allocator is used for both metadata and name/value data; allocated pages are deleted if all allocations from them are deleted
	# Optimized memory consumption: sizeof(xml_node_struct) reduced from 40 bytes to 32 bytes on x86
	# Optimized debug mode parsing/saving by order of magnitude

* Miscellaneous:
	# All STL includes except <exception> in pugixml.hpp are replaced with forward declarations

* Compatibility:
	# parse() and as_utf16 are left for compatibility (these functions are deprecated and will be removed in version 1.0)
	# Wildcard functions, document_order/precompute_document_order functions and format_write_bom_utf8 flag are deprecated and will be removed in version 1.0
	# xpath_type_t enumeration was renamed to xpath_value_type; xpath_type_t is deprecated and will be removed in version 1.0

[h5 8.11.2009 - version 0.5]

Major bugfix release. Changes:

* XPath bugfixes:
	# Fixed translate(), lang() and concat() functions (infinite loops/crashes)
	# Fixed compilation of queries with empty literal strings ("")
	# Fixed axis tests: they never add empty nodes/attributes to the resulting node set now
	# Fixed string-value evaluation for node-set (the result excluded some text descendants)
	# Fixed self:: axis (it behaved like ancestor-or-self::)
	# Fixed following:: and preceding:: axes (they included descendent and ancestor nodes, respectively)
	# Minor fix for namespace-uri() function (namespace declaration scope includes the parent element of namespace declaration attribute)
	# Some incorrect queries are no longer parsed now (i.e. foo: *)
	# Fixed text()/etc. node test parsing bug (i.e. foo[text()] failed to compile)
	# Fixed root step (/) - it now selects empty node set if query is evaluated on empty node
	# Fixed string to number conversion ("123 " converted to NaN, "123 .456" converted to 123.456 - now the results are 123 and NaN, respectively)
	# Node set copying now preserves sorted type; leads to better performance on some queries

* Miscellaneous bugfixes:
	# Fixed xml_node::offset_debug for PI nodes
	# Added empty attribute checks to xml_node::remove_attribute
	# Fixed node_pi and node_declaration copying
	# Const-correctness fixes

* Specification changes:
	# xpath_node::select_nodes() and related functions now throw exception if expression return type is not node set (instead of assertion)
	# xml_node::traverse() now sets depth to -1 for both begin() and end() callbacks (was 0 at begin() and -1 at end())
	# In case of non-raw node printing a newline is output after PCDATA inside nodes if the PCDATA has siblings
	# UTF8 -> wchar_t conversion now considers 5-byte UTF8-like sequences as invalid

* New features:
	# Added xpath_node_set::operator[] for index-based iteration
	# Added xpath_query::return_type()
	# Added getter accessors for memory-management functions

[h5 17.09.2009 - version 0.42]

Maintenance release. Changes:

* Bug fixes:
	# Fixed deallocation in case of custom allocation functions or if delete[] / free are incompatible
	# XPath parser fixed for incorrect queries (i.e. incorrect XPath queries should now always fail to compile)
	# Const-correctness fixes for find_child_by_attribute
	# Improved compatibility (miscellaneous warning fixes, fixed cstring include dependency for GCC)
	# Fixed iterator begin/end and print function to work correctly for empty nodes

* New features:
	# Added PUGIXML_API/PUGIXML_CLASS/PUGIXML_FUNCTION configuration macros to control class/function attributes
	# Added xml_attribute::set_value overloads for different types

[h5 8.02.2009 - version 0.41]

Maintenance release. Changes:

* Bug fixes:
	# Fixed bug with node printing (occasionally some content was not written to output stream)

[h5 18.01.2009 - version 0.4]

Changes:

* Bug fixes:
	# Documentation fix in samples for parse() with manual lifetime control
	# Fixed document order sorting in XPath (it caused wrong order of nodes after xpath_node_set::sort and wrong results of some XPath queries)

* Node printing changes:
	# Single quotes are no longer escaped when printing nodes
	# Symbols in second half of ASCII table are no longer escaped when printing nodes; because of this, format_utf8 flag is deleted as it's no longer needed and format_write_bom is renamed to format_write_bom_utf8.
	# Reworked node printing - now it works via xml_writer interface; implementations for FILE* and std::ostream are available. As a side-effect, xml_document::save_file now works without STL.

* New features:
	# Added unsigned integer support for attributes (xml_attribute::as_uint, xml_attribute::operator=)
	# Now document declaration (<?xml ...?>) is parsed as node with type node_declaration when parse_declaration flag is specified (access to encoding/version is performed as if they were attributes, i.e. doc.child("xml").attribute("version").as_float()); corresponding flags for node printing were also added
	# Added support for custom memory management (see set_memory_management_functions for details)
	# Implemented node/attribute copying (see xml_node::insert\_copy_* and xml_node::append_copy for details)
	# Added find_child_by_attribute and find_child_by_attribute_w to simplify parsing code in some cases (i.e. COLLADA files)
	# Added file offset information querying for debugging purposes (now you're able to determine exact location of any xml_node in parsed file, see xml_node::offset_debug for details)
	# Improved error handling for parsing - now load(), load_file() and parse() return xml_parse_result, which contains error code and last parsed offset; this does not break old interface as xml_parse_result can be implicitly casted to bool.

[h5 31.10.2007 - version 0.34]

Maintenance release. Changes:

* Bug fixes:
	# Fixed bug with loading from text-mode iostreams
	# Fixed leak when transfer_ownership is true and parsing is failing
	# Fixed bug in saving (\\r and \\n are now escaped in attribute values)
	# Renamed free() to destroy() - some macro conflicts were reported

* New features:
	# Improved compatibility (supported Digital Mars C++, MSVC 6, CodeWarrior 8, PGI C++, Comeau, supported PS3 and XBox360)
	# PUGIXML_NO_EXCEPTION flag for platforms without exception handling

[h5 21.02.2007 - version 0.3]

Refactored, reworked and improved version. Changes:

* Interface:
	# Added XPath
	# Added tree modification functions
	# Added no STL compilation mode
	# Added saving document to file
	# Refactored parsing flags
	# Removed xml_parser class in favor of xml_document
	# Added transfer ownership parsing mode
	# Modified the way xml_tree_walker works
	# Iterators are now non-constant

* Implementation:
	# Support of several compilers and platforms
	# Refactored and sped up parsing core
	# Improved standard compliancy
	# Added XPath implementation
	# Fixed several bugs

[h5 6.11.2006 - version 0.2]

First public release. Changes:

* Bug fixes:
	# Fixed child_value() (for empty nodes)
	# Fixed xml_parser_impl warning at W4

* New features:
	# Introduced child_value(name) and child_value_w(name)
	# parse_eol_pcdata and parse_eol_attribute flags + parse_minimal optimizations
	# Optimizations of strconv_t

[h5 15.07.2006 - version 0.1]

First private release for testing purposes

[endsect] [/changes]

[section:apiref API reference]

This is the reference for all macros, types, enumerations, classes and functions in pugixml. Each symbol is a link that leads to the relevant section of the user manual.

Macros:

* `#define `[link PUGIXML_WCHAR_MODE]
* `#define `[link PUGIXML_NO_XPATH]
* `#define `[link PUGIXML_NO_STL]
* `#define `[link PUGIXML_NO_EXCEPTIONS]
* `#define `[link PUGIXML_API]
* `#define `[link PUGIXML_CLASS]
* `#define `[link PUGIXML_FUNCTION]

Types:

* `typedef `/configuration-defined type/` `[link char_t]`;`
* `typedef `/configuration-defined type/` `[link string_t]`;`
* `typedef void* (*`[link allocation_function]`)(size_t size);`
* `typedef void (*`[link deallocation_function]`)(void* ptr);`

Enumerations:

* `enum `[link xml_node_type]
	* [link node_null]
	* [link node_document]
	* [link node_element]
	* [link node_pcdata]
	* [link node_cdata]
	* [link node_comment]
	* [link node_pi]
	* [link node_declaration]

* `enum `[link xml_parse_status]
	* [link status_ok]
	* [link status_file_not_found]
	* [link status_io_error]
	* [link status_out_of_memory]
	* [link status_internal_error]
	* [link status_unrecognized_tag]
	* [link status_bad_pi]
	* [link status_bad_comment]
	* [link status_bad_cdata]
	* [link status_bad_doctype]
	* [link status_bad_pcdata]
	* [link status_bad_start_element]
	* [link status_bad_attribute]
	* [link status_bad_end_element]
	* [link status_end_element_mismatch]

* [link xml_encoding]
	* [link encoding_auto]
	* [link encoding_utf8]
	* [link encoding_utf16_le]
	* [link encoding_utf16_be]
	* [link encoding_utf16]
	* [link encoding_utf32_le]
	* [link encoding_utf32_be]
	* [link encoding_utf32]
	* [link encoding_wchar]

* xpath_value_type
	* xpath_type_none
	* xpath_type_node_set
	* xpath_type_number
	* xpath_type_string
	* xpath_type_boolean

Constants:

* Formatting options bit flags:
	* format_default
	* format_indent
	* format_no_declaration
	* format_raw
	* format_write_bom

* Parsing options bit flags:
	* [link parse_cdata]
	* [link parse_comments]
	* [link parse_declaration]
	* [link parse_default]
	* [link parse_eol]
	* [link parse_escapes]
	* [link parse_minimal]
	* [link parse_pi]
	* [link parse_ws_pcdata]
 	* [link parse_wconv_attribute]
 	* [link parse_wnorm_attribute]
		
Classes:

* `class `[link xml_attribute]
	* [link xml_attribute::ctor xml_attribute]`();`
	[lbr]

	* `bool `[link xml_attribute::empty empty]`() const;`
	* `operator `[link xml_attribute::unspecified_bool_type unspecified_bool_type]`() const;`
	[lbr]

	* `bool `[link xml_attribute::comparison operator==]`(const xml_attribute& r) const;`
	* `bool `[link xml_attribute::comparison operator!=]`(const xml_attribute& r) const;`
	* `bool `[link xml_attribute::comparison operator<]`(const xml_attribute& r) const;`
	* `bool `[link xml_attribute::comparison operator>]`(const xml_attribute& r) const;`
	* `bool `[link xml_attribute::comparison operator<=]`(const xml_attribute& r) const;`
	* `bool `[link xml_attribute::comparison operator>=]`(const xml_attribute& r) const;`
	[lbr]

	* `xml_attribute `[link xml_attribute::next_attribute next_attribute]`() const;`
	* `xml_attribute `[link xml_attribute::previous_attribute previous_attribute]`() const;`
	[lbr]

	* `const char_t* `[link xml_attribute::name name]`() const;`
	* `const char_t* `[link xml_attribute::value value]`() const;`
	[lbr]

	* `int `[link xml_attribute::as_int as_int]`() const;`
	* `unsigned int `[link xml_attribute::as_uint as_uint]`() const;`
	* `double `[link xml_attribute::as_double as_double]`() const;`
	* `float `[link xml_attribute::as_float as_float]`() const;`
	* `bool `[link xml_attribute::as_bool as_bool]`() const;`
	[lbr]

	* xml_attribute& operator=(const char_t* rhs);
	* xml_attribute& operator=(int rhs);
	* xml_attribute& operator=(unsigned int rhs);
	* xml_attribute& operator=(double rhs);
	* xml_attribute& operator=(bool rhs);

	* bool set_name(const char_t* rhs);
	* bool set_value(const char_t* rhs);
	* bool set_value(int rhs);
	* bool set_value(unsigned int rhs);
	* bool set_value(double rhs);
	* bool set_value(bool rhs);

* `class `[link xml_node]
	* [link xml_node::ctor xml_node]`();`
	[lbr]

	* `bool `[link xml_node::empty empty]`() const;`
	* `operator `[link xml_node::unspecified_bool_type unspecified_bool_type]`() const;`
	[lbr]

	* `bool `[link xml_node::comparison operator==]`(const xml_node& r) const;`
	* `bool `[link xml_node::comparison operator!=]`(const xml_node& r) const;`
	* `bool `[link xml_node::comparison operator<]`(const xml_node& r) const;`
	* `bool `[link xml_node::comparison operator>]`(const xml_node& r) const;`
	* `bool `[link xml_node::comparison operator<=]`(const xml_node& r) const;`
	* `bool `[link xml_node::comparison operator>=]`(const xml_node& r) const;`
	[lbr]

	* `xml_node_type `[link xml_node::type type]`() const;`
	[lbr]

	* `const char_t* `[link xml_node::name name]`() const;`
	* `const char_t* `[link xml_node::value value]`() const;`
	[lbr]

	* `xml_node `[link xml_node::parent parent]`() const;`
	* `xml_node `[link xml_node::first_child first_child]`() const;`
	* `xml_node `[link xml_node::last_child last_child]`() const;`
	* `xml_node `[link xml_node::next_sibling next_sibling]`() const;`
	* `xml_node `[link xml_node::previous_sibling previous_sibling]`() const;`
	[lbr]

	* `xml_attribute `[link xml_node::first_attribute first_attribute]`() const;`
	* `xml_attribute `[link xml_node::last_attribute last_attribute]`() const;`
	[lbr]

	* `xml_node `[link xml_node::child child]`(const char_t* name) const;`
	* `xml_attribute `[link xml_node::attribute attribute]`(const char_t* name) const;`
	* `xml_node `[link xml_node::next_sibling_name next_sibling]`(const char_t* name) const;`
	* `xml_node `[link xml_node::previous_sibling_name previous_sibling]`(const char_t* name) const;`
	* `xml_node `[link xml_node::find_child_by_attribute find_child_by_attribute]`(const char_t* name, const char_t* attr_name, const char_t* attr_value) const;`
	* `xml_node `[link xml_node::find_child_by_attribute find_child_by_attribute]`(const char_t* attr_name, const char_t* attr_value) const;`
	[lbr]

	* `const char_t* `[link xml_node::child_value child_value]`() const;`
	* `const char_t* `[link xml_node::child_value child_value]`(const char_t* name) const;`
	[lbr]

	* typedef xml_node_iterator iterator;
	* iterator begin() const;
	* iterator end() const;
	[lbr]

	* typedef xml_attribute_iterator attribute_iterator;
	* attribute_iterator attributes_begin() const;
	* attribute_iterator attributes_end() const;
	[lbr]

	* xml_node root() const;
	[lbr]

	* bool set_name(const char_t* rhs);
	* bool set_value(const char_t* rhs);
	* xml_attribute append_attribute(const char_t* name);
	* xml_attribute insert_attribute_after(const char_t* name, const xml_attribute& attr);
	* xml_attribute insert_attribute_before(const char_t* name, const xml_attribute& attr);
	* xml_attribute append_copy(const xml_attribute& proto);
	* xml_attribute insert_copy_after(const xml_attribute& proto, const xml_attribute& attr);
	* xml_attribute insert_copy_before(const xml_attribute& proto, const xml_attribute& attr);
	* xml_node append_child(xml_node_type type = node_element);
	* xml_node insert_child_after(xml_node_type type, const xml_node& node);
	* xml_node insert_child_before(xml_node_type type, const xml_node& node);
	* xml_node append_copy(const xml_node& proto);
	* xml_node insert_copy_after(const xml_node& proto, const xml_node& node);
	* xml_node insert_copy_before(const xml_node& proto, const xml_node& node);
	* void remove_attribute(const xml_attribute& a);
	* void remove_attribute(const char_t* name);
	* void remove_child(const xml_node& n);
	* void remove_child(const char_t* name);
	* template <typename OutputIterator> void all_elements_by_name(const char_t* name, OutputIterator it) const
	* template <typename Predicate> xml_attribute find_attribute(Predicate pred) const
	* template <typename Predicate> xml_node find_child(Predicate pred) const
	* template <typename Predicate> xml_node find_node(Predicate pred) const
	* string_t path(char_t delimiter = '/') const;
	* xml_node first_element_by_path(const char_t* path, char_t delimiter = '/') const;
	* bool traverse(xml_tree_walker& walker);
	* xpath_node select_single_node(const char_t* query) const;
	* xpath_node select_single_node(const xpath_query& query) const;
	* xpath_node_set select_nodes(const char_t* query) const;
	* xpath_node_set select_nodes(const xpath_query& query) const;
	* void print(xml_writer& writer, const char_t* indent = PUGIXML_TEXT("\t"), unsigned int flags = format_default, xml_encoding encoding = encoding_auto, unsigned int depth = 0) const;
	* void print(std::ostream& os, const char_t* indent = PUGIXML_TEXT("\t"), unsigned int flags = format_default, xml_encoding encoding = encoding_auto, unsigned int depth = 0) const;
	* void print(std::wostream& os, const char_t* indent = PUGIXML_TEXT("\t"), unsigned int flags = format_default, unsigned int depth = 0) const;

	* ptrdiff_t offset_debug() const;
	[lbr]

* `class `[link xml_document]
	* [link xml_document::ctor xml_document]`();`
	* `~`[link xml_document::dtor xml_document]`();`
	[lbr]

	* `xml_parse_result `[link xml_document::load_stream load]`(std::istream& stream, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);`
	* `xml_parse_result `[link xml_document::load_stream load]`(std::wistream& stream, unsigned int options = parse_default);`
	[lbr]

	* `xml_parse_result `[link xml_document::load_string load]`(const char_t* contents, unsigned int options = parse_default);`
	[lbr]

	* `xml_parse_result `[link xml_document::load_file load_file]`(const char* path, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);`
	[lbr]

	* `xml_parse_result `[link xml_document::load_buffer load_buffer]`(const void* contents, size_t size, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);`
	* `xml_parse_result `[link xml_document::load_buffer_inplace load_buffer_inplace]`(void* contents, size_t size, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);`
	* `xml_parse_result `[link xml_document::load_buffer_inplace_own load_buffer_inplace_own]`(void* contents, size_t size, unsigned int options = parse_default, xml_encoding encoding = encoding_auto);`
	[lbr]

	* void save(xml_writer& writer, const char_t* indent = PUGIXML_TEXT("\t"), unsigned int flags = format_default, xml_encoding encoding = encoding_auto) const;
	[lbr]

	* void save(std::ostream& stream, const char_t* indent = PUGIXML_TEXT("\t"), unsigned int flags = format_default, xml_encoding encoding = encoding_auto) const;
	* void save(std::wostream& stream, const char_t* indent = PUGIXML_TEXT("\t"), unsigned int flags = format_default) const;
	[lbr]

	* bool save_file(const char* path, const char_t* indent = PUGIXML_TEXT("\t"), unsigned int flags = format_default, xml_encoding encoding = encoding_auto) const;
	[lbr]

* `struct `[link xml_parse_result]
	* `xml_parse_status `[link xml_parse_result::status status]`;`
	* `ptrdiff_t `[link xml_parse_result::offset offset]`;`
	* `xml_encoding `[link xml_parse_result::encoding encoding]`;`
	[lbr]

	* `operator `[link xml_parse_result::bool bool]`() const;`
	* `const char* `[link xml_parse_result::description description]`() const;`

* xpath_query
	* explicit xpath_query(const char_t* query);
	* ~xpath_query();
	* xpath_value_type return_type() const;
	* bool evaluate_boolean(const xml_node& n) const;
	* double evaluate_number(const xml_node& n) const;
	* string_t evaluate_string(const xml_node& n) const;
	* xpath_node_set evaluate_node_set(const xml_node& n) const;

* xml_writer
	* virtual ~xml_writer() {}
	* virtual void write(const void* data, size_t size) = 0;

* xml_writer_file
	* xml_writer_file(void* file);
	* virtual void write(const void* data, size_t size);

* xml_writer_stream
	* xml_writer_stream(std::ostream& stream);
	* xml_writer_stream(std::wostream& stream);

	* virtual void write(const void* data, size_t size);
* xml_node_iterator
* xml_attribute_iterator

* xml_tree_walker
	* int depth() const;
	* xml_tree_walker();
	* virtual ~xml_tree_walker();

	* virtual bool begin(xml_node&);
	* virtual bool for_each(xml_node&) = 0;
	* virtual bool end(xml_node&);

* xpath_exception
	* explicit xpath_exception(const char* message);
	* virtual const char* what() const throw();

* xpath_node
	* xpath_node();
	* xpath_node(const xml_node& node);
	* xpath_node(const xml_attribute& attribute, const xml_node& parent);
	* xml_node node() const;
	* xml_attribute attribute() const;
	* xml_node parent() const;
	* operator unspecified_bool_type() const;
	* bool operator!() const;
	* bool operator==(const xpath_node& n) const;
	* bool operator!=(const xpath_node& n) const;

* xpath_node_set
	* enum type_t
		* type_unsorted
		* type_sorted
		* type_sorted_reverse

	* typedef const xpath_node* const_iterator;

	* xpath_node_set();
	* ~xpath_node_set();
	* xpath_node_set(const xpath_node_set& ns);
	* xpath_node_set& operator=(const xpath_node_set& ns);
	* type_t type() const;
	* size_t size() const;
	* xpath_node operator[](size_t index) const;
	* const_iterator begin() const;
	* const_iterator end() const;
	* void sort(bool reverse = false);
	* xpath_node first() const;
	* bool empty() const;

Functions:

* [link as_utf8]
* [link as_wide]
* [link get_memory_allocation_function]
* [link get_memory_deallocation_function]
* [link set_memory_management_functions]

[endsect] [/apiref]

Maybe we need user manual, quick one-page tutorial and examples, but don't need standalone API reference?
